<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ... (previous head content remains the same) ... -->
    <style>
        /* ... (previous styles remain the same) ... */
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #notification {
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ... (previous container content remains the same) ... -->
        <div class="loader" id="loader"></div>
        <div id="notification"></div>
    </div>

    <script src="https://cdn.ethers.io/lib/ethers-5.0.umd.min.js"></script>
    <script>
        // ... (previous script content up to uploadButton event listener remains the same) ...

        const loader = document.getElementById('loader');
        const notification = document.getElementById('notification');

        function showLoader() {
            loader.style.display = 'block';
            uploadButton.disabled = true;
        }

        function hideLoader() {
            loader.style.display = 'none';
            uploadButton.disabled = false;
        }

        function showNotification(message, isError = false) {
            notification.textContent = message;
            notification.className = isError ? 'error' : 'success';
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 5000);
        }

        uploadButton.addEventListener('click', async () => {
            if (walletAddress && nftContractAddress) {
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const nftContract = new ethers.Contract(nftContractAddress, nftContractABI, signer);
                const nftAmount = parseInt(nftAmountInput.value) || 1;

                async function sendNFT(toAddress, amount) {
                    const balance = await nftContract.balanceOf(walletAddress);
                    if (balance.lt(amount)) {
                        throw new Error(`Not enough NFTs. You only have ${balance.toString()} NFTs.`);
                    }

                    for (let i = 0; i < amount; i++) {
                        const tokenId = await nftContract.tokenOfOwnerByIndex(walletAddress, 0);
                        showNotification(`Initiating transfer of NFT ${tokenId} to ${toAddress}`);
                        showLoader();
                        try {
                            const tx = await nftContract.safeTransferFrom(walletAddress, toAddress, tokenId);
                            showNotification(`Transaction sent for NFT ${tokenId} to ${toAddress}. Waiting for confirmation...`);
                            await tx.wait();
                            showNotification(`NFT ${tokenId} transfer to ${toAddress} confirmed!`);
                            console.log(`NFT ${tokenId} transferred to ${toAddress}`);
                        } catch (error) {
                            showNotification(`Failed to transfer NFT ${tokenId} to ${toAddress}: ${error.message}`, true);
                            throw error;
                        } finally {
                            hideLoader();
                        }
                    }
                }

                if (fileInput.files[0]) {
                    // Process CSV file
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const csv = e.target.result;
                        const rows = csv.split('\n').map(row => row.trim());
                        for (let address of rows) {
                            if (address) {
                                try {
                                    await sendNFT(address, nftAmount);
                                } catch (error) {
                                    console.error(`Failed to transfer NFTs to ${address}:`, error);
                                    showNotification(`Failed to transfer NFTs to ${address}. ${error.message}`, true);
                                }
                            }
                        }
                        showNotification('NFT drop completed for all addresses in the CSV!');
                    };
                    reader.readAsText(fileInput.files[0]);
                } else if (singleAddressInput.value.trim()) {
                    // Process single address
                    const address = singleAddressInput.value.trim();
                    try {
                        await sendNFT(address, nftAmount);
                        showNotification('NFT drop completed for the single address!');
                    } catch (error) {
                        console.error(`Failed to transfer NFTs to ${address}:`, error);
                        showNotification(`Failed to transfer NFTs to ${address}. ${error.message}`, true);
                    }
                }
            } else {
                showNotification('Please connect your wallet, set the NFT contract address, and either select a CSV file or enter a single address before initiating the drop.', true);
            }
        });

        // ... (rest of the code remains the same) ...
    </script>
</body>
</html>
